{
  "kind": "build_request",
  "title": "Retry: Minimum Google OAuth security hardening (single-use state, 10 min TTL, safe linking rules, no token logging)",
  "priority": "normal",
  "requirements": [
    {
      "id": "REQ-171",
      "text": "Implement a secure OAuth `state` lifecycle for the backend Google OAuth flow: each generated `state` must be single-use and must expire after 10 minutes (TTL). The backend must persist `state` values server-side, validate them in the callback (exists, not expired, not used), and then immediately mark them as used and/or remove them so they cannot be replayed.",
      "target": "backend",
      "source": {
        "messageIds": [
          "recent-messages-4"
        ],
        "quotes": [
          "„Dodaj zabezpieczenia:\nstate jednorazowy (po użyciu usuń/oznacz used)\nTTL 10 min\""
        ]
      },
      "acceptanceCriteria": [
        "Calling the backend Google OAuth start endpoint generates a new random `state` value that is persisted server-side with an expiration time exactly 10 minutes after creation.",
        "In the callback flow, a `state` that is missing, expired, or already used is rejected with a non-success outcome (no user linking/creation is performed for invalid state).",
        "After a successful callback validation, the `state` is immediately made unusable for any future callback attempts (deleted or marked `used = true` and treated as invalid).",
        "Expired and/or used `state` records are cleaned up deterministically so storage cannot grow without bound (e.g., cleanup on each start/callback invocation)."
      ]
    },
    {
      "id": "REQ-172",
      "text": "Enforce Google account linking rules during Google OAuth user mapping: if Google `email_verified` is `false`, the backend must NOT link the Google identity to an existing user by matching email. In that case, the backend must follow the project’s intended behavior (create a new user or block), but it must not attach Google OAuth fields to an existing account based on unverified email.",
      "target": "backend",
      "source": {
        "messageIds": [
          "recent-messages-4"
        ],
        "quotes": [
          "„jeśli email_verified od Google jest false → nie linkuj do istniejącego konta po email (tylko twórz nowe lub blokuj)\""
        ]
      },
      "acceptanceCriteria": [
        "When Google userinfo returns `email_verified = false` and an existing user has the same email, the backend does not set/update that existing user’s `(oauth_provider, oauth_subject)` based on email match.",
        "When Google userinfo returns `email_verified = true`, the existing email-linking behavior (if implemented) may link by email as before (subject to the system’s existing uniqueness/index rules).",
        "All cases continue to enforce uniqueness for `(oauth_provider, oauth_subject)` so that the same Google identity cannot be linked to multiple users."
      ]
    },
    {
      "id": "REQ-173",
      "text": "Ensure tokens and other sensitive OAuth secrets are never written to logs in the backend Google OAuth flow. This includes (at minimum) OAuth authorization codes, `access_token`, `refresh_token`, `id_token`, and any application-issued tokens; log only short, stable error codes when needed.",
      "target": "backend",
      "source": {
        "messageIds": [
          "recent-messages-4"
        ],
        "quotes": [
          "„nie loguj tokenów w logach”"
        ]
      },
      "acceptanceCriteria": [
        "Backend code paths for Google OAuth start/callback do not log token values, authorization codes, or raw Google responses that contain tokens.",
        "If the backend logs OAuth-related failures, logs contain only non-sensitive information (e.g., a machine-readable error code) and do not include query parameters that may contain tokens/codes.",
        "A code review pass is applied to the backend Google OAuth flow to remove/avoid any `Debug.print`/logging that could include sensitive values."
      ]
    },
    {
      "id": "REQ-174",
      "text": "Maintain upgrade safety for any new/changed backend persisted state introduced by the OAuth hardening (e.g., OAuth state storage shape). If stable memory layout changes are required, add a conditional `backend/migration.mo` and wire it according to the project migration policy so canister upgrades do not brick existing deployments.",
      "target": "backend",
      "source": {
        "messageIds": [
          "recent-messages-4",
          "recent-messages-6"
        ],
        "quotes": [
          "„Dodaj zabezpieczenia… state jednorazowy… TTL 10 min”",
          "Sproboj raz jeszcze"
        ]
      },
      "acceptanceCriteria": [
        "If the implementation changes stable state layout, an explicit conditional migration is provided that initializes new OAuth-related state deterministically on upgrade.",
        "Upgrading from the currently deployed version to the new version succeeds without trapping during `postupgrade` and leaves the canister in a usable state."
      ]
    }
  ],
  "constraints": [
    "Backend must remain a single-actor Motoko canister; keep all logic in `backend/main.mo` and only introduce `backend/migration.mo` when required by stable-state changes.",
    "Do not log OAuth tokens, application tokens, or other secrets in backend logs.",
    "Use English for any user-facing text introduced as part of these changes."
  ],
  "nonGoals": [
    "Add a new audit log feature for OAuth or state usage (not requested in this retry).",
    "Introduce third-party auth providers beyond Google OAuth.",
    "Refactor unrelated room/game logic outside what is necessary to implement the security hardening."
  ],
  "imageRequirements": {
    "required": [],
    "edits": []
  },
  "userProfileUpdate": {
    "goalsToAdd": [],
    "goalsToRemove": [],
    "preferencesToAdd": [],
    "preferencesToRemove": [],
    "miscToAdd": [],
    "miscToRemove": [],
    "fieldsToSet": {},
    "fieldsToDelete": []
  }
}